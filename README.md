# Лабораторная работа 1
**Руководство пользователя Описание кнопок и функций**

*Файл:* 
1. Создать: Создает новый документ. Если текущий документ содержит несохраненные изменения, программа предложит сохранить их. 
2. Открыть: Открывает существующий текстовый файл. Вы можете выбрать файл через диалоговое окно. 
3. Сохранить: Сохраняет текущий документ. Если файл уже был сохранен ранее, изменения будут записаны в тот же файл. Если файл новый, откроется диалоговое окно для выбора места сохранения. 
4. Сохранить как: Сохраняет текущий документ под новым именем или в новом месте. 
5. Выход: Закрывает программу. Если есть несохраненные изменения, программа предложит сохранить их перед выходом.

*Правка:*
1. Отменить: Отменяет последнее действие. 
2. Повторить: Повторяет последнее отмененное действие. 
3. Вырезать: Вырезает выделенный текст и помещает его в буфер обмена. 
4. Копировать: Копирует выделенный текст в буфер обмена. 
5. Вставить: Вставляет текст из буфера обмена в текущую позицию курсора. 
6. Удалить: Удаляет выделенный текст. 
7. Выделить все: Выделяет весь текст в документе.

*Текст:*
1. Постановка задачи: Отображает описание задачи, для которой создан текстовый редактор.
2. Грамматика: Показывает грамматические правила, используемые в языковом процессоре. 
3. Классификация грамматики: Описывает тип грамматики, используемой в программе. 
4. Метод анализа: Описывает метод, используемый для анализа текста. 
5. Диагностика и нейтрализация ошибок: Описывает, как программа обнаруживает и исправляет ошибки в тексте. 
6. Тестовый пример: Предоставляет пример текста для тестирования функциональности программы. 
7. Список литературы: Содержит список использованной литературы. 
8. Исходный код программы: Показывает исходный код программы (если доступно).

*Пуск:*
1. Запуск анализатора: Запускает языковой процессор для анализа текста. Результаты анализа отображаются в области результатов.
Справка:
2. Вызов справки: Открывает это руководство пользователя. 
3. О программе: Показывает информацию о программе, включая версию и автора.

# Лабораторная работа 2
Персональный вариант: Лямбда-выражения языка Python

## Постановка задачи 
Необходимо разработать лексический анализатор, который будет выделять заданные типы лексем из исходного текста и обнаруживать недопустимые символы, спроектировать диаграмму состояний сканера, реализовать алгоритм анализа многострочного текста и интегрировать модуль в интерфейс текстового редактора с визуализацией результатов.Также требуется обеспечить обработку ошибок с указанием их местоположения и формирование таблицы распознанных лексем.

## Примеры допустимых строк:
- calc = lambda a, b, c: a + (b * c)
- calc = lam@@bda a, b, c: a + (b * c);
- calc lambda a, b, c: a + (b * c);

## Тестовые примеры:
![image](https://github.com/user-attachments/assets/745ab296-a550-490e-b654-82fda6ada616)
![image](https://github.com/user-attachments/assets/15dd2f12-67a0-4ba6-bff0-7f9a54f8e5de)
![image](https://github.com/user-attachments/assets/5e9baa5d-81cd-40f6-8d3f-4a42cf0cabd2)

# Лабораторная работа 3
## Разработка синтаксического анализатора (парсера).
## Вариант задания 
Лямбда-выражения языка Python
Строка: calc = lambda a, b, c: a + (b * c);;
## Примеры допустимых строк
- calc = lambda a, b, c: a + (b * c)
- calc = lam@@bda a, b, c: a + (b * c);
- calc lambda a, b, c: a + (b * c);
## Разработка грамматики
Определим грамматику лямбда-выражения языка Python G[<START>] в нотации Хомского с продукциями P:
![Снимок экрана (16)](https://github.com/user-attachments/assets/64258cae-d93d-4209-a978-c5381ea0059c)
![Снимок экрана (17)](https://github.com/user-attachments/assets/f8b8629c-c9b0-498a-a8f4-269cf605318b)


## Классификация грамматики
Согласно классификации Хомского, грамматика G[<START>] является контекстно-свободной (КС-грамматикой), так как все её продукции имеют форму A → α, где A ∈ VN (один нетерминал) и α ∈ V* (произвольная последовательность терминалов и/или нетерминалов). 
Данное правило позволяет обрабатывать выражения произвольной глубины вложенности: 
Данная грамматика относится к классу контекстно-свободных, так как все её продукции заменяют ровно один нетерминал без контекстных ограничений. Она поддерживает рекурсивные структуры и вложенные выражения, что характерно для КС-грамматик, но недопустимо в регулярных грамматиках.

## Список процедур
![image](https://github.com/user-attachments/assets/e7a620f6-7aee-44d2-95e3-7b404bb6e305)


## Тестовые примеры:
![image](https://github.com/user-attachments/assets/745ab296-a550-490e-b654-82fda6ada616)
![image](https://github.com/user-attachments/assets/15dd2f12-67a0-4ba6-bff0-7f9a54f8e5de)
![image](https://github.com/user-attachments/assets/5e9baa5d-81cd-40f6-8d3f-4a42cf0cabd2)

# Лабораторная работа 4 
## Нейтрализация ошибок (метод Айронса)
## Вариант задания 
Лямбда-выражения языка Python
Строка: calc = lambda a, b, c: a + (b * c);;
## Примеры допустимых строк
- calc = lambda a, b, c: a + (b * c)
- calc = lam@@bda a, b, c: a + (b * c);
- calc lambda a, b, c: a + (b * c);
## Разработка грамматики
Определим грамматику лямбда-выражения языка Python G[<START>] в нотации Хомского с продукциями P:
![Снимок экрана (16)](https://github.com/user-attachments/assets/64258cae-d93d-4209-a978-c5381ea0059c)
![Снимок экрана (17)](https://github.com/user-attachments/assets/f8b8629c-c9b0-498a-a8f4-269cf605318b)

## Классификация грамматики
Согласно классификации Хомского, грамматика G[<START>] является контекстно-свободной (КС-грамматикой), так как все её продукции имеют форму A → α, где A ∈ VN (один нетерминал) и α ∈ V* (произвольная последовательность терминалов и/или нетерминалов). 
Данное правило позволяет обрабатывать выражения произвольной глубины вложенности: 
Данная грамматика относится к классу контекстно-свободных, так как все её продукции заменяют ровно один нетерминал без контекстных ограничений. Она поддерживает рекурсивные структуры и вложенные выражения, что характерно для КС-грамматик, но недопустимо в регулярных грамматиках.

## Список процедур
![image](https://github.com/user-attachments/assets/e7a620f6-7aee-44d2-95e3-7b404bb6e305)

## Тестовые примеры:
![image](https://github.com/user-attachments/assets/745ab296-a550-490e-b654-82fda6ada616)
![image](https://github.com/user-attachments/assets/15dd2f12-67a0-4ba6-bff0-7f9a54f8e5de)
![image](https://github.com/user-attachments/assets/5e9baa5d-81cd-40f6-8d3f-4a42cf0cabd2)

# Лабораторная работа 6
## Задачи
1. Построить РВ для поиска идентификатора, который может начинаться только с буквы a-zA-Z, знака доллара $ или подчеркивания _, оставшаяся часть символов идентификатора представляют собой только буквы a-zA-Z.
2. Построить РВ, описывающее многострочные комментарии (язык Python).
3. Построить РВ, описывающее регистрационный знак транспортного средства (Vehicle Identification Number).
## Регулярные выражения
Задача 1 <br>
@"\b[$_\w][\w]*\b"

Задача 2 <br>
"\"\"\"[\\s\\S]*?\"\"\""

Задача 3 <br>
@"\b[A-HJ-NPR-Z0-9]{17}\b"

## Тестовые примеры 
![image](https://github.com/user-attachments/assets/c2e234d5-43d1-4d57-bdad-ffe2afaef772) <br>
![image](https://github.com/user-attachments/assets/322d934c-81e7-4359-a6f9-7ab62e580d16) <br>
![image](https://github.com/user-attachments/assets/b189ab8f-6bad-4262-a322-a7f07863fd9b)

# Лабораторная работа 7
# Преобразование и анализ кода с использованием Clang и LLVM
Цель работы: Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе (например, список функций). 
Задачи:
1. Установить Clang и LLVM;
2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;
3. Использовать opt для применения базовой комплексной оптимизации (например, О2);
4. Построить граф потока управления (CFG) для оптимизированной программы;
5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы

## 1. Установка и подготовка среды
Работа выполнялась в среде macos. Установлены следующие инструменты: <br>
● clang — компилятор языка C/C++;<br>
● llvm — инструменты анализа и оптимизации кода; <br>
● opt — инструмент для работы с LLVM IR и применения оптимизаций; <br>
● Graphviz — инструмент для визуализации кода. Команда установки: sudo apt install clang llvm <br>
<img width="1684" alt="Снимок экрана 2025-06-09 в 03 14 15" src="https://github.com/user-attachments/assets/44bd9aee-5e1d-4744-8269-c788788e750b" /> <br>
<img width="1709" alt="Снимок экрана 2025-06-09 в 03 22 22" src="https://github.com/user-attachments/assets/1cb97b24-a13d-4fae-a94e-a81b2265b514" /> <br>

## 2. Исходный код программы для демонстрации работы инструментов (сохранена в main.c):
<img width="264" alt="Снимок экрана 2025-06-09 в 03 34 49" src="https://github.com/user-attachments/assets/99db26c9-f319-4f8f-9a66-16142d93e65c" /> <br>

## 3. Получение AST
Команда: clang -Xclang -ast-dump -fsyntax-only main.c
<img width="1709" alt="Снимок экрана 2025-06-09 в 03 34 20" src="https://github.com/user-attachments/assets/ecec8243-5a92-4867-9e42-a1dcb973aeb1" /> <br>
Square принята, содержит параметр x и возвращает x * x.

## 4. Генерация LLVM IR
Команда: clang -S -emit-llvm main.c -o main.ll
<img width="1710" alt="Снимок экрана 2025-06-09 в 03 40 23" src="https://github.com/user-attachments/assets/c01a83fd-33ca-433e-baa1-4152b2c9f756" /> <br>

## 5. Оптимизация IR
Команда: clang -O0 -S -emit-llvm main.c -o main_O0.ll , <br>
Стоит отметить, что в файле с IR до оптимизации:  <br>
Все переменные (a, b, x.addr) размещены в памяти через alloca; <br>
Множество операций load и store; <br>
square вызывается как отдельная функция <br>
<img width="1710" alt="Снимок экрана 2025-06-09 в 05 13 44" src="https://github.com/user-attachments/assets/54c03e37-a6ae-493d-9d21-25bddf263de0" /> <br>

Команда: clang -O2 -S -emit-llvm main.c -o main_O2.ll
Команда -O2 – комплексная оптимизация среднего уровня. Она применяет более 30 различных оптимизаций: <br>
● -inline – встраивание небольших функций (встраивает square в main, если она вызывается один раз); <br>
● -constprop – подставит значение square(5) → 25, если функция встроена и всё известно на этапе компиляции; <br>
● -mem2reg – перевод переменных из памяти в регистры (SSA); <br>
● -instcombine – объединение и упрощение инструкций (упростит арифметику, например x * x может быть преобразовано в shl при x = 2^n); <br>
● -simplifycfg – оптимизирует структуру блоков (Упростит граф управления, если после inlining останутся лишние блоки); <br>
● -reassociate, -gvn, -sroa, -dce и другие. <br>
В файле с IR после оптимизации: <br>
Вся функция square исчезла – она была встроена (-inline) и затем вычислена (оптимизация -constprop); <br>
Никаких переменных, alloca, store, load – всё удалено (оптимизации -mem2reg, -dce); <br>
Остался только вызов printf(25). <br>
<img width="1699" alt="Снимок экрана 2025-06-09 в 05 14 53" src="https://github.com/user-attachments/assets/ae6d0737-7748-4124-ada3-1eec4abac986" /> <br>

Команда: diff main_O0.ll main_O2.ll Сравнение двух файлов:
<img width="1710" alt="Снимок экрана 2025-06-09 в 03 51 31" src="https://github.com/user-attachments/assets/6948c0cc-a93d-49b4-83ac-e0b79ddceebf" /> <br>
Стоит отметить, что после оптимизации произошли следующие изменения:
- Переменные типа alloca были удалены; <br>
- Код переведён в SSA-форму; <br>
- Оптимизация улучшила читаемость и упростила поток управления. <br>

## 6. Граф потока управления программы
Команда для генерации оптимизированного LLVM IR: clang -O2 -S -emit-llvm main.c -o main.ll <br> 
Команда для генерации .dot-файлов CFG для функций: opt -dot-cfg -disable-output main.ll <br>
<img width="1710" alt="Снимок экрана 2025-06-09 в 04 10 59" src="https://github.com/user-attachments/assets/70ed4a32-bf81-4664-b71c-11de30f0f008" /> <br>

Эта команда создаст DOT-файлы: .main.dot – для функции main; .square.dot – для square, если она не была удалена оптимизацией. <br>
Команда для установки библиотеки Graphviz: sudo apt install graphviz <br>
Команды для преобразования файлов с расширением .dot в .png с помощью Graphviz: <br>

dot -Tpng .main.dot -o cfg_main.png <br>
dot -Tpng .square.dot -o cfg_square.png <br>

Команды для просмотра файлов с CGF: <br>

xdg-open cfg_main.png <br>
<img width="660" alt="Снимок экрана 2025-06-09 в 04 17 05" src="https://github.com/user-attachments/assets/7de54f16-d389-4325-b934-80183ff78914" /> <br>

xdg-open cfg_square.png <br>
<img width="287" alt="Снимок экрана 2025-06-09 в 04 17 16" src="https://github.com/user-attachments/assets/5d077e5c-7186-4727-81dc-ff145df4f67b" /> <br>

Стоит отметить, что в LLVM каждый граф потока управления (CFG) строится на уровне функции, поскольку структура управления всегда локальна для тела функции. Для получения полного представления о программе, нужно построить CFG для всех функций и анализировать их совокупность. Автоматическое объединение всех CFG в один граф не предусмотрено в LLVM по умолчанию.

Выводы: <br>
● С помощью Clang можно получить полную структуру AST и IR, а также CGF; <br>
● LLVM предоставляет гибкие инструменты анализа и оптимизации; <br>
● Промежуточное представление кода удобно для написания компиляторных трансформаций. <br>

## Ответы на контрольные вопросы 
1. Что такое Clang и какова его роль в процессе компиляции? <br>
Clang — это инструмент для преобразования программ, написанных на языках C, C++, Objective-C и других, в промежуточный код. Он анализирует исходный текст, строит дерево синтаксических структур, проверяет смысл написанного и превращает его в код, пригодный для последующей оптимизации и генерации исполняемых файлов.

2. Что такое LLVM и как он применяется в компиляторах? <br>
LLVM — это набор библиотек и компонентов, которые позволяют создавать гибкие и мощные компиляторы. Он выступает как механизм, обрабатывающий и улучшающий промежуточный код, а также адаптирующий его под разные архитектуры процессоров.

3. Чем AST отличается от LLVM IR? <br>
Абстрактное синтаксическое дерево (AST) отражает логическую структуру программы на языке программирования — его удобно использовать для анализа смысла кода. Промежуточное представление (IR), наоборот, ближе к машинному уровню — оно более формализовано и пригодно для технической обработки и оптимизации.

4. Для чего нужно промежуточное представление (IR)? <br>
IR служит связующим звеном между анализом исходного кода и созданием машинных инструкций. Оно делает компилятор более гибким, позволяет реализовывать общие методы оптимизации и адаптироваться под различные устройства.

5. Что делает alloca в LLVM IR? <br>
Инструкция alloca выделяет место в памяти на стековой области функции, чтобы использовать его, например, для хранения временных данных. Это похоже на создание локальных переменных в обычной программе на C.

6. Зачем компилятор оптимизирует код? <br>
Цель оптимизации — сделать программу быстрее, компактнее и менее ресурсоёмкой. Это достигается путём преобразования кода без изменения его результата, чтобы программа работала эффективнее.

7. Что такое SSA и зачем она нужна? <br>
SSA-форма (статическое одноназначное присваивание) — это способ представления кода, при котором каждая переменная получает значение только один раз. Это делает анализ зависимостей проще и позволяет проводить оптимизации более эффективно.

8. Что такое граф потока управления (CFG) и зачем он нужен? <br>
CFG — это схема, показывающая возможные переходы исполнения программы между участками кода. Она помогает понять, как программа выполняется, и используется для анализа поведения и оптимизации логики выполнения.

9. Как отображаются арифметические действия в LLVM IR? <br>
В LLVM IR арифметика записывается в виде инструкций, вроде add (сложение), mul (умножение) и т. д., с указанием типов данных. Каждая операция создаёт новую переменную с результатом.

10. Почему функции в LLVM IR анализируются отдельно? <br>
Поскольку функции независимы и имеют чёткие границы, их удобно рассматривать как отдельные единицы. Это упрощает анализ и позволяет оптимизировать каждую функцию по отдельности, не затрагивая остальной код.

11. Что произойдёт с короткой функцией, которая вызывается один раз? <br>
Скорее всего, такая функция будет "вставлена" в место вызова (инлайн). Это уменьшает накладные расходы на вызов и открывает дополнительные возможности для оптимизации.

12. Почему IR и CFG удобнее для оптимизации, чем исходный код на C? <br>
Исходный код на C сложен из-за синтаксиса и возможных неоднозначностей. IR и CFG дают более точное и универсальное представление программы, которое проще анализировать и преобразовывать автоматически, независимо от исходного языка.

# Лабораторная работа 8
## Грамматика
1 вариант
Для грамматики G[E] разработать и реализовать алгоритм анализа на
основе метода рекурсивного спуска.
G[E]:
1. E → TA
2. A → ε | + TA | - TA
3. T → ОВ
4. В → ε | *ОВ | /ОВ
5. О → num | id | (E)
num – числовая константа Ц{Ц}, id – идентификатор Б{Б|Ц}, Б – {a,
b, c, ...z, A, B, …, Z}, Ц – {0, 1, …, 9}.

## Язык
L(G[E]) = {num, id, ( ), +, -, *, /}, где num – числовая константа Ц{Ц}, id – идентификатор Б{Б|Ц}, Б – {a, b, c, ...z, A, B, …, Z}, Ц – {0, 1, …, 9}.

## Классификация грамматики
Согласно классификации Хомского, грамматика G[Е] является контекстно-свободной, так как имеет вид: A → α, где A∈VN, α∈V*.

## Схема вызова функций
<img width="866" alt="Снимок экрана 2025-06-09 в 00 45 41" src="https://github.com/user-attachments/assets/a2ed3b42-b73f-4e38-83e8-dc7b04080421" />

## Тестовые примеры
![image_2025-06-09_00-49-33](https://github.com/user-attachments/assets/3f15b468-5617-4598-aa48-669924affe95) <br>

![telegram-cloud-document-2-5345890980958602947](https://github.com/user-attachments/assets/f7df9f7d-57f0-4003-abdf-ca05f1e75b81) <br>

![telegram-cloud-photo-size-2-5345890981414827253-x](https://github.com/user-attachments/assets/927c465c-ae4d-4a7e-8846-c01475f31f86)


  

